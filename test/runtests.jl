using Test
using ChouChem
using Printf

# --- Helper Functions ---

function mkMol(Coord, BasisSet::String)
	Mol = Vector{Atom}()
	for atom in Coord
		push!(Mol, Atom(atom[1], atom[2], BasisSet, atom[3]))
	end
	return Mol
end

function write_g16_input(filename, method_g16, basis_g16, charge, mult, coords)
	open(filename, "w") do io
		println(io, "%Mem=8000MB")
		println(io, "%NProcShared=8")
		println(io, "#p $method_g16/$basis_g16")
		println(io, "")
		println(io, "Generated by ChouChem Test Suite")
		println(io, "")
		println(io, "$charge $mult")
		for atom in coords
			@printf(io, "% -2s  %12.8f  %12.8f  %12.8f\n", atom[1], atom[3][1], atom[3][2], atom[3][3])
	end
		println(io, "")
	end
end

# --- Data Definitions ---

HFCoord = [
	("H", 1, (0.000, 0.000, 0.000)),
	("F", 9, (0.000, 0.000, 1.500)),
]

H2OCoord = [
	("O", 8, (0.0000, 0.0000, 0.0000)),
	("H", 1, (0.0000, 1.0000, 0.8000)),
	("H", 1, (0.0000, -1.0000, 0.8000)),
]

# Define Molecules: (Name, Coords)
Molecules = [
	("HF", HFCoord),
	("H2O", H2OCoord)
]

BasisSets = ["STO-3G", "6-31G"]

# Define Charges/Mults and associated methods to test
# Structure: (Charge, Mult, List of Methods)
# Method Entry: (TestName, Function, Args, G16Keyword)
# Args is a tuple of additional args passed to the function AFTER Mol, Charge, Mult.
# Note: Keyword args like MaxIter are handled inside the loop logic or wrapper.

TestConfigs = [
	# Neutral Singlet (Closed Shell)
	(0, 1, [
		("RHF",   RunRHF,   (),                 "RHF"),
		("RMP2",  RunRMPn,  (2,),               "MP2"),
		("RCI",   RunRCI,   (2,),               "CISD"),
		("RCCSD", RunRCCSD, (),                 "CCSD")
	]),
	# Cation Doublet (Open Shell)
	(1, 2, [
		("UHF",   RunUHF,   (),                 "UHF"),
		("UCI",   RunUCI,   (2,),               "CISD"),
		("UCCSD", RunUCCSD, (),                 "CCSD")
	])
]

TestResults = Vector{Tuple{String, String, String, String, Float64}}() # Mol, Basis, Charge, Method, Energy
G16_Dir = "test_g16"

GaussianRef = Dict{Tuple{String, String, String, String}, Float64}(
    ("HF", "STO-3G", "0", "RHF") => -98.4147504971,
    ("HF", "STO-3G", "0", "RMP2") => -98.4731173972,
    ("HF", "STO-3G", "0", "RCI") => -98.4731173972,
    ("HF", "STO-3G", "0", "RCCSD") => -98.4731173972,
    ("HF", "STO-3G", "1", "UHF") => -98.1167715367,
    ("HF", "STO-3G", "1", "UCI") => -98.1302228343,
    ("HF", "STO-3G", "1", "UCCSD") => -98.1302228343,
    ("HF", "6-31G", "0", "RHF") => -99.8550549963,
    ("HF", "6-31G", "0", "RMP2") => -100.0132125658,
    ("HF", "6-31G", "0", "RCI") => -100.0132125658,
    ("HF", "6-31G", "0", "RCCSD") => -100.0132125658,
    ("HF", "6-31G", "1", "UHF") => -99.4226454320,
    ("HF", "6-31G", "1", "UCI") => -99.5138510961,
    ("HF", "6-31G", "1", "UCCSD") => -99.5138510961,
    ("H2O", "STO-3G", "0", "RHF") => -74.8492756161,
    ("H2O", "STO-3G", "0", "RMP2") => -74.9218206470,
    ("H2O", "STO-3G", "0", "RCI") => -74.9218206470,
    ("H2O", "STO-3G", "0", "RCCSD") => -74.9218206470,
    ("H2O", "STO-3G", "1", "UHF") => -74.5963826272,
    ("H2O", "STO-3G", "1", "UCI") => -74.6420002218,
    ("H2O", "STO-3G", "1", "UCCSD") => -74.6420002218,
    ("H2O", "6-31G", "0", "RHF") => -75.8727852890,
    ("H2O", "6-31G", "0", "RMP2") => -76.0321821615,
    ("H2O", "6-31G", "0", "RCI") => -76.0321821615,
    ("H2O", "6-31G", "0", "RCCSD") => -76.0321821615,
    ("H2O", "6-31G", "1", "UHF") => -75.5120874774,
    ("H2O", "6-31G", "1", "UCI") => -75.6213992971,
    ("H2O", "6-31G", "1", "UCCSD") => -75.6213992971
)

# --- Main Test Loop ---

@testset "ChouChem Tests" begin
	for (mol_name, coords) in Molecules
		@testset "$mol_name" begin
			for basis in BasisSets
				@testset "$basis" begin
					# Prepare Molecule Object
					MolObj = mkMol(coords, basis)

					for (charge, mult, methods) in TestConfigs
						charge_str = charge == 0 ? "Neutral" : "Cation"
						@testset "$charge_str (Q=$charge, M=$mult)" begin
							for (method_name, func, args, g16_key) in methods
								@testset "$method_name" begin
									# 1. Run Julia Test
									# Handle kwargs dynamically if needed, mostly for MaxIter/Threshold
									# The Run* functions usually take (Mol, Charge, Mult, [Args...]; Kwargs...)
									
									# Special handling for args to match function signatures
									# RunRHF(Mol, C, M)
									# RunUHF(Mol, C, M; MaxIter, Threshold)
									# RunRMPn(Mol, C, M, n)
									# RunUCI(Mol, C, M, MaxExcitation; MaxIter...)
									# RunRCI(Mol, C, M, MaxExcitation)
									# RunRCCSD(Mol, C, M)
									# RunUCCSD(Mol, C, M; MaxIter)

									local result = nothing
									try
										if method_name == "RHF"
											result = func(MolObj, charge, mult)
										elseif method_name == "UHF"
											result = func(MolObj, charge, mult; MaxIter=512)
										elseif method_name == "RMP2"
											result = func(MolObj, charge, mult, args...)
										elseif method_name == "UCI"
											result = func(MolObj, charge, mult, args...; MaxIter=512)
										elseif method_name == "RCI"
											result = func(MolObj, charge, mult, args...)
										elseif method_name == "RCCSD"
											result = func(MolObj, charge, mult)
										elseif method_name == "UCCSD"
											result = func(MolObj, charge, mult; MaxIter=512)
									end
								catch e
									println("Error running $method_name for $mol_name/$basis: $e")
									# Allow failure for expensive methods on large basis if strictly needed, 
									# but here we expect success.
									throw(e)
								end

									@test result !== nothing
									
									# Extract Energy
									# Different result structs have different fields for Total Energy
									# RHF/UHF: Etot
									# RMPn: EtotMPn
									# CI: EtotCI
									# CCSD: EtotCCSD
									
									energy = 0.0
									if hasproperty(result, :Etot)
										energy = result.Etot
									elseif hasproperty(result, :EtotMPn)
										energy = result.EtotMPn
									elseif hasproperty(result, :EtotCI)
										energy = result.EtotCI
									elseif hasproperty(result, :EtotCCSD)
										energy = result.EtotCCSD
								end
									
									push!(TestResults, (mol_name, basis, "$charge", method_name, energy))

									# 2. Generate G16 Input
								g16_filename = joinpath(G16_Dir, "$(mol_name)_$(basis)_Q$(charge)_$(method_name).gjf")
								write_g16_input(g16_filename, g16_key, basis, charge, mult, coords)
								end
							end
						end
					end
				end
			end
		end
	end
end

# --- Summary Output ---

println("\n" * "="^120)
println(" "^45 * "TEST RESULTS SUMMARY")
println("="^120)
@printf("%-8s | %-8s | %-3s | %-8s | %-16s | %-16s | %s\n", "Mol", "Basis", "Q", "Method", "ChouChem", "Gaussian", "Diff (Ha)")
println("-"^120)
for r in TestResults
    mol, basis, q, method, chou_e = r
    g16_e = get(GaussianRef, (mol, basis, q, method), NaN)
    diff = abs(chou_e - g16_e)
    status = isnan(g16_e) ? "N/A" : (diff < 1e-6 ? "OK" : "DIFF")
    if status == "DIFF" && diff < 1e-3
        status = "DIFF(Small)"
    elseif status == "DIFF" && diff < 5e-2
        status = "DIFF(Med)"
    end
    
	@printf("%-8s | %-8s | %-3s | %-8s | %16.10f | %16.10f | %10.2e %s\n", mol, basis, q, method, chou_e, g16_e, diff, status)
end
println("="^120 * "\n")